const { tursoClient } = require('./backend/lib/tursoClient.js');

// Configuraci√≥n de colores para la consola
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  blue: '\x1b[34m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m'
};

/**
 * üîÑ MIGRACI√ìN M√ìDULO AUDITOR√çAS AL SISTEMA SGC ESTANDARIZADO
 * 
 * Este script migra los datos del m√≥dulo de auditor√≠as para usar las 3 tablas gen√©ricas SGC:
 * - sgc_participantes (para auditores, auditados, testigos)
 * - sgc_documentos_relacionados (para planes, listas, evidencias, informes)
 * - sgc_normas_relacionadas (para puntos ISO evaluados - migra desde auditoria_aspectos)
 */

async function migrarAuditoriasToSGC(organizationId = '2') {
  try {
    console.log(`${colors.cyan}${colors.bright}üîÑ MIGRACI√ìN AUDITOR√çAS A SISTEMA SGC ESTANDARIZADO${colors.reset}`);
    console.log(`${colors.blue}üìÖ Fecha: ${new Date().toLocaleString('es-ES')}${colors.reset}`);
    console.log(`${colors.blue}üè¢ Organizaci√≥n ID: ${organizationId}${colors.reset}`);
    console.log(''.padEnd(80, '='));

    // FASE 1: VERIFICAR ESTADO ACTUAL
    console.log(`\n${colors.magenta}üìä FASE 1: VERIFICACI√ìN DE ESTADO ACTUAL${colors.reset}`);
    
    // Verificar tablas existentes
    console.log(`\n${colors.yellow}üîç Verificando tablas existentes...${colors.reset}`);
    
    const auditoriasCount = await contarRegistros('auditorias', organizationId);
    const aspectosCount = await contarRegistros('auditoria_aspectos');
    
    console.log(`   ${colors.green}‚úÖ auditorias: ${auditoriasCount} registros${colors.reset}`);
    console.log(`   ${colors.green}‚úÖ auditoria_aspectos: ${aspectosCount} registros${colors.reset}`);

    // Verificar tablas SGC objetivo
    const sgcParticipantesCount = await contarRegistros('sgc_participantes', organizationId);
    const sgcDocumentosCount = await contarRegistros('sgc_documentos_relacionados', organizationId);
    const sgcNormasCount = await contarRegistros('sgc_normas_relacionadas', organizationId);
    
    console.log(`   ${colors.blue}üìä sgc_participantes: ${sgcParticipantesCount} registros${colors.reset}`);
    console.log(`   ${colors.blue}üìä sgc_documentos_relacionados: ${sgcDocumentosCount} registros${colors.reset}`);
    console.log(`   ${colors.blue}üìä sgc_normas_relacionadas: ${sgcNormasCount} registros${colors.reset}`);

    if (aspectosCount === 0) {
      console.log(`\n${colors.yellow}‚ö†Ô∏è  No hay aspectos de auditor√≠a para migrar${colors.reset}`);
      return;
    }

    // FASE 2: MIGRACI√ìN DE DATOS auditoria_aspectos ‚Üí sgc_normas_relacionadas
    console.log(`\n${colors.magenta}üîÑ FASE 2: MIGRACI√ìN DE ASPECTOS A NORMAS SGC${colors.reset}`);
    
    console.log(`\n${colors.yellow}üìã Migrando ${aspectosCount} aspectos de auditor√≠a...${colors.reset}`);
    
    // Obtener todos los aspectos de auditor√≠a
    const aspectosResult = await tursoClient.execute({
      sql: `
        SELECT 
          aa.*,
          a.organization_id,
          a.titulo as auditoria_titulo
        FROM auditoria_aspectos aa
        INNER JOIN auditorias a ON aa.auditoria_id = a.id
        WHERE a.organization_id = ?
      `,
      args: [organizationId]
    });

    let migrados = 0;
    let errores = 0;

    for (const aspecto of aspectosResult.rows) {
      try {
        // Generar ID √∫nico para el registro de norma
        const normaId = `NOR_AUD_${aspecto.id}`;
        
        // Determinar nivel de cumplimiento basado en conformidad
        let nivelCumplimiento = 'pendiente';
        if (aspecto.conformidad) {
          switch (aspecto.conformidad.toLowerCase()) {
            case 'conforme':
            case 'cumple':
              nivelCumplimiento = 'cumple';
              break;
            case 'no conforme':
            case 'no cumple':
              nivelCumplimiento = 'no_cumple';
              break;
            case 'observacion':
              nivelCumplimiento = 'oportunidad_mejora';
              break;
            default:
              nivelCumplimiento = 'pendiente';
          }
        }

        // Crear observaciones completas
        let observacionesCompletas = [];
        if (aspecto.proceso_nombre) observacionesCompletas.push(`Proceso: ${aspecto.proceso_nombre}`);
        if (aspecto.documentacion_referenciada) observacionesCompletas.push(`Documentaci√≥n: ${aspecto.documentacion_referenciada}`);
        if (aspecto.auditor_nombre) observacionesCompletas.push(`Auditor: ${aspecto.auditor_nombre}`);
        if (aspecto.observaciones) observacionesCompletas.push(`Observaciones: ${aspecto.observaciones}`);

        const observacionesFinal = observacionesCompletas.join(' | ');

        // Insertar en sgc_normas_relacionadas
        await tursoClient.execute({
          sql: `
            INSERT INTO sgc_normas_relacionadas (
              id, organization_id, entidad_tipo, entidad_id, norma_id,
              punto_norma, clausula_descripcion, tipo_relacion,
              nivel_cumplimiento, observaciones, evidencias,
              acciones_requeridas, datos_adicionales,
              created_at, updated_at, created_by, updated_by, is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `,
          args: [
            normaId,
            aspecto.organization_id,
            'auditoria',
            aspecto.auditoria_id,
            1, // ISO 9001 por defecto
            aspecto.proceso_nombre || 'Proceso no especificado',
            `Aspecto evaluado en auditor√≠a: ${aspecto.auditoria_titulo}`,
            'evaluado_en_auditoria',
            nivelCumplimiento,
            observacionesFinal,
            aspecto.documentacion_referenciada || null,
            aspecto.conformidad === 'no conforme' ? 'Implementar acciones correctivas' : null,
            JSON.stringify({
              aspecto_original_id: aspecto.id,
              auditor_nombre: aspecto.auditor_nombre,
              conformidad_original: aspecto.conformidad,
              proceso_id: aspecto.proceso_id
            }),
            aspecto.created_at || new Date().toISOString(),
            new Date().toISOString(),
            null,
            null,
            1
          ]
        });

        migrados++;
        console.log(`   ${colors.green}‚úÖ Migrado aspecto ${aspecto.id} ‚Üí ${normaId}${colors.reset}`);

      } catch (error) {
        errores++;
        console.log(`   ${colors.red}‚ùå Error migrando aspecto ${aspecto.id}: ${error.message}${colors.reset}`);
      }
    }

    console.log(`\n${colors.green}üìä RESULTADO MIGRACI√ìN ASPECTOS:${colors.reset}`);
    console.log(`   ${colors.green}‚úÖ Migrados exitosamente: ${migrados}${colors.reset}`);
    console.log(`   ${colors.red}‚ùå Errores: ${errores}${colors.reset}`);

    // FASE 3: CREAR PARTICIPANTES DE EJEMPLO PARA AUDITOR√çAS
    console.log(`\n${colors.magenta}üë• FASE 3: CREAR PARTICIPANTES DE EJEMPLO${colors.reset}`);
    
    // Obtener auditor√≠as que tienen responsable asignado
    const auditoriasConResponsable = await tursoClient.execute({
      sql: `
        SELECT a.*, p.nombres, p.apellidos 
        FROM auditorias a
        LEFT JOIN personal p ON a.responsable_id = p.id
        WHERE a.organization_id = ? AND a.responsable_id IS NOT NULL
      `,
      args: [organizationId]
    });

    let participantesCreados = 0;
    
    for (const auditoria of auditoriasConResponsable.rows) {
      try {
        // Crear participante como auditor l√≠der
        const participanteId = `PAR_AUD_${auditoria.id}_${auditoria.responsable_id}`;
        
        await tursoClient.execute({
          sql: `
            INSERT OR IGNORE INTO sgc_participantes (
              id, organization_id, entidad_tipo, entidad_id,
              personal_id, rol, asistio, observaciones,
              datos_adicionales, created_at, updated_at, is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `,
          args: [
            participanteId,
            organizationId,
            'auditoria',
            auditoria.id,
            auditoria.responsable_id,
            'auditor_lider',
            1,
            `Responsable asignado de la auditor√≠a: ${auditoria.titulo}`,
            JSON.stringify({
              auditoria_codigo: auditoria.codigo,
              fecha_programada: auditoria.fecha_programada,
              areas: auditoria.area
            }),
            new Date().toISOString(),
            new Date().toISOString(),
            1
          ]
        });

        participantesCreados++;
        console.log(`   ${colors.green}‚úÖ Participante creado para auditor√≠a ${auditoria.codigo}${colors.reset}`);

      } catch (error) {
        if (!error.message.includes('UNIQUE constraint failed')) {
          console.log(`   ${colors.yellow}‚ö†Ô∏è  Participante ya existe para auditor√≠a ${auditoria.codigo}${colors.reset}`);
        }
      }
    }

    console.log(`\n${colors.green}üìä PARTICIPANTES CREADOS: ${participantesCreados}${colors.reset}`);

    // FASE 4: VERIFICACI√ìN POST-MIGRACI√ìN
    console.log(`\n${colors.magenta}üîç FASE 4: VERIFICACI√ìN POST-MIGRACI√ìN${colors.reset}`);
    
    const normasMigradas = await tursoClient.execute({
      sql: `
        SELECT COUNT(*) as total FROM sgc_normas_relacionadas 
        WHERE entidad_tipo = 'auditoria' AND organization_id = ?
      `,
      args: [organizationId]
    });

    const participantesAuditorias = await tursoClient.execute({
      sql: `
        SELECT COUNT(*) as total FROM sgc_participantes 
        WHERE entidad_tipo = 'auditoria' AND organization_id = ?
      `,
      args: [organizationId]
    });

    console.log(`\n${colors.blue}üìä ESTADO POST-MIGRACI√ìN:${colors.reset}`);
    console.log(`   ${colors.green}üèõÔ∏è Normas SGC para auditor√≠as: ${normasMigradas.rows[0].total}${colors.reset}`);
    console.log(`   ${colors.green}üë• Participantes en auditor√≠as: ${participantesAuditorias.rows[0].total}${colors.reset}`);

    // FASE 5: RECOMENDACIONES
    console.log(`\n${colors.magenta}üí° FASE 5: RECOMENDACIONES${colors.reset}`);
    console.log(`\n${colors.cyan}üìã PR√ìXIMOS PASOS:${colors.reset}`);
    console.log(`   1. ${colors.yellow}Verificar datos migrados en interfaz${colors.reset}`);
    console.log(`   2. ${colors.yellow}Actualizar backend con endpoints SGC${colors.reset}`);
    console.log(`   3. ${colors.yellow}Expandir frontend con nuevas funcionalidades${colors.reset}`);
    console.log(`   4. ${colors.yellow}Eliminar tabla auditoria_aspectos (DESPU√âS de verificar)${colors.reset}`);

    if (migrados === aspectosCount && errores === 0) {
      console.log(`\n${colors.green}${colors.bright}üéâ MIGRACI√ìN COMPLETADA EXITOSAMENTE${colors.reset}`);
      console.log(`${colors.green}‚úÖ Todos los aspectos fueron migrados correctamente${colors.reset}`);
    } else {
      console.log(`\n${colors.yellow}‚ö†Ô∏è  MIGRACI√ìN COMPLETADA CON ADVERTENCIAS${colors.reset}`);
      console.log(`${colors.yellow}üìù Revisar errores antes de eliminar tabla original${colors.reset}`);
    }

  } catch (error) {
    console.error(`${colors.red}‚ùå Error durante la migraci√≥n:${colors.reset}`, error);
    process.exit(1);
  }
}

// Funci√≥n auxiliar para contar registros
async function contarRegistros(tabla, organizationId = null) {
  try {
    let sql = `SELECT COUNT(*) as total FROM ${tabla}`;
    let args = [];
    
    if (organizationId && tabla !== 'auditoria_aspectos') {
      sql += ` WHERE organization_id = ?`;
      args = [organizationId];
    }
    
    const result = await tursoClient.execute({ sql, args });
    return result.rows[0]?.total || 0;
  } catch (error) {
    console.log(`   ${colors.red}‚ùå Error contando ${tabla}: ${error.message}${colors.reset}`);
    return 0;
  }
}

// Funci√≥n para ejecutar migraci√≥n con par√°metros
async function main() {
  const args = process.argv.slice(2);
  const organizationId = args[0] || '2';
  
  console.log(`${colors.cyan}üöÄ Iniciando migraci√≥n de auditor√≠as al sistema SGC...${colors.reset}`);
  
  await migrarAuditoriasToSGC(organizationId);
}

// Manejo de se√±ales para salida limpia
process.on('SIGINT', () => {
  console.log(`\n${colors.yellow}üëã Migraci√≥n interrumpida por el usuario${colors.reset}`);
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log(`\n${colors.yellow}üëã Migraci√≥n terminada${colors.reset}`);
  process.exit(0);
});

// Exportar funci√≥n para uso en otros m√≥dulos
module.exports = { migrarAuditoriasToSGC };

// Ejecutar si se llama directamente
if (require.main === module) {
  main();
}
